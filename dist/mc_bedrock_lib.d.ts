// Generated by dts-bundle-generator v9.5.1

import { Dimension, Entity, EquipmentSlot, ItemStack, Player, ScriptEventCommandMessageAfterEventSignal, System, WeatherType, World, WorldAfterEvents, WorldBeforeEvents } from '@minecraft/server';

export declare class CountDownTimer {
	timer: number;
	minutes: number;
	seconds: string | number;
	process: any;
	constructor(durationInSeconds?: number, onEnd?: () => void, onUpdate?: (min: number, sec: string | number) => void);
	dispose(): void;
}
export interface CommandResult {
	successCount: number;
}
export interface Fade {
	fadeIn: number;
	fadeHold: number;
	fadeOut: number;
}
export interface Scene {
	posStart: any;
	posEnd: any;
	rotStart: any;
	rotEnd: any;
	duration: number;
	fade: Fade;
	ease_type: string;
}
export interface TimedCommand {
	timeTick: number;
	commands: string[];
}
export declare class Cutscene {
	target: any;
	scenes: Scene[];
	timedCommands: TimedCommand[];
	is_invisible: boolean;
	is_spectator: boolean;
	constructor(target: any, scenes: Scene[], timedCommands?: TimedCommand[], is_spectator?: boolean, is_invisible?: boolean);
	play(): void;
}
export declare class DebugStickInspector {
	private _interval;
	constructor();
	dispose(): void;
	private _updatePlayers;
}
declare class Event$1 {
	constructor();
}
declare class AfterEvent extends Event$1 {
	constructor();
}
export declare class EntityAfterEvent extends AfterEvent {
	entity: Entity;
	constructor(entity: Entity);
}
export declare class PlayerAfterEvent extends AfterEvent {
	player: Player;
	constructor(player: Player);
}
export declare class EntityOnGroundAfterEvent extends EntityAfterEvent {
	constructor(entity: Entity);
}
export declare class EntityJumpAfterEvent extends EntityAfterEvent {
	constructor(entity: Entity);
}
export declare class EntitySneakAfterEvent extends EntityAfterEvent {
	constructor(entity: Entity);
}
export declare class EntityUnsneakAfterEvent extends EntityAfterEvent {
	constructor(entity: Entity);
}
export declare class PlayerOnAirJumpAfterEvent extends PlayerAfterEvent {
	constructor(player: Player);
}
export declare class PlayerOnLandAfterEvent extends PlayerAfterEvent {
	constructor(player: Player);
}
export declare class ItemAfterEvent extends PlayerAfterEvent {
	itemStack: ItemStack;
	constructor(player: Player, itemStack: ItemStack);
}
export declare class PlayerOnEquipAfterEvent extends ItemAfterEvent {
	equipmentSlot: EquipmentSlot;
	constructor(player: Player, itemStack: ItemStack, equipmentSlot: EquipmentSlot);
}
export declare class PlayerOnUnequipAfterEvent extends PlayerOnEquipAfterEvent {
	constructor(player: Player, itemStack: ItemStack, equipmentSlot: EquipmentSlot);
}
export declare class EventSignal {
	protected _events: Map<string, any>;
	protected _process: any;
	protected _isDisposed: boolean;
	constructor();
	subscribe(cb: (e: any) => void): void;
	unsubscribe(): void;
	protected _run(cb: (e: any) => void): void;
}
export declare class EntityEventSignal extends EventSignal {
	protected _entityIds: Set<string>;
	constructor();
}
export declare class EntityItemEventSignal extends EntityEventSignal {
	protected _items: Set<string>;
	constructor();
}
export declare class EntityJumpAfterEventSignal extends EntityEventSignal {
	constructor();
	protected _run(cb: (e: EntityJumpAfterEvent) => void): void;
}
export declare class EntityStartJumpingAfterEventSignal extends EntityEventSignal {
	constructor();
	protected _run(cb: (e: EntityJumpAfterEvent) => void): void;
}
export declare class EntityStopJumpingAfterEventSignal extends EntityEventSignal {
	constructor();
	protected _run(cb: (e: EntityJumpAfterEvent) => void): void;
}
export declare class EntitySneakAfterEventSignal extends EntityEventSignal {
	constructor();
	protected _run(cb: (e: EntitySneakAfterEvent) => void): void;
}
export declare class EntityUnsneakAfterEventSignal extends EntityEventSignal {
	private _sneaking;
	constructor();
	protected _run(cb: (e: EntityUnsneakAfterEvent) => void): void;
}
export declare class PlayerOnAirJumpAfterEventSignal extends EntityEventSignal {
	private _onAir;
	constructor();
	protected _run(cb: (e: PlayerOnAirJumpAfterEvent) => void): void;
}
export declare class PlayerOnEquipAfterEventSignal extends EntityEventSignal {
	private _previousEquipments;
	constructor();
	protected _run(cb: (e: PlayerOnEquipAfterEvent) => void): void;
}
export declare class PlayerOnUnequipAfterEventSignal extends EntityEventSignal {
	private _previousEquipments;
	constructor();
	protected _run(cb: (e: PlayerOnUnequipAfterEvent) => void): void;
}
export declare class PlayerOnLandAfterEventSignal extends EntityEventSignal {
	constructor();
	protected _run(cb: (e: PlayerOnLandAfterEvent) => void): void;
}
export declare class Vector2 {
	x: number;
	z: number;
	private _y;
	constructor(x: number | {
		x: number;
		y: number;
		z?: number;
	}, y?: number);
	set y(value: number);
	get y(): number;
	toString(): string;
	offset(x: number | {
		x: number;
		y: number;
	}, y?: number): Vector2;
	check(x: number, y: number): boolean;
	normalized(): Vector2;
}
export declare class Vector3 extends Vector2 {
	z: number;
	constructor(x: number | string | {
		x: number;
		y: number;
		z?: number;
	}, y?: number, z?: number);
	offset(x: number | {
		x: number;
		y: number;
	}, y?: number): Vector2;
	offset(x: number | {
		x: number;
		y: number;
		z?: number;
	}, y?: number, z?: number): Vector3;
	check(x: number, y: number): boolean;
	check(x: number, y: number, z: number): boolean;
	toVector2(): Vector2;
	toString(): string;
	belowCenter(): Vector3;
	center(): Vector3;
	sizeCenter(): Vector3;
	sizeBelowCenter(): Vector3;
	private _roundToNearestHalf;
	normalized(): Vector3;
	toVolume(vec: Vector3): Vector3;
}
export declare class Run {
	protected _process: any;
	constructor();
	dispose(): void;
}
export declare class RunInterval extends Run {
	constructor(cb: () => void, interval?: number);
}
export declare class RunTimeOut extends Run {
	constructor(cb: () => void, timeOut?: number);
}
export declare const namespace: string;
export declare const world: World;
export declare const system: System;
export declare const afterEvents: WorldAfterEvents;
export declare const beforeEvents: WorldBeforeEvents;
export declare const scriptEvent: ScriptEventCommandMessageAfterEventSignal;
export declare function defineProperties(target: object, properties: Record<string, PropertyDescriptor>): void;
export declare function getRandomElement<T>(array: T[]): T;
export declare function generateUUIDv4(): string;
export declare function idTranslate(id: string): string;
export declare function runCommand(this: Entity | Dimension, source: typeof Entity | typeof Dimension, ...commands: string[] | string[][]): CommandResult;
export declare function display(value: any, type?: "chat" | "error" | "log"): void;
export declare function arraysEqual(arr1: any[], arr2: any[]): boolean;
export declare const playersUsingItem: Set<string>;
export declare const weatherTracker: Map<number, WeatherType>;

export {};

declare global {
  interface String {
    toTitleCase(): string;
    toVector2(): Vector2 | undefined;
    toVector3(): Vector3 | undefined;
    toEQO(): Record<string, any> | undefined;
  }

  interface Math {
    randomInt(min: number, max: number): number;
  }
}

declare module "@minecraft/server" {
  interface World {
    getEntities(selector?: any): Entity[];
    readonly players: Player[];
    readonly end: Dimension;
    readonly overworld: Dimension;
    readonly nether: Dimension;
  }
  interface WorldAfterEvents {
    readonly entityJump: EntityJumpAfterEventSignal;
    readonly entityStartJumping: EntityStartJumpingAfterEventSignal;
    readonly entityStopJumping: EntityStopJumpingAfterEventSignal;
    readonly entitySneak: EntitySneakAfterEventSignal;
    readonly entityUnsneak: EntityUnsneakAfterEventSignal;
    readonly playerOnAirJump: PlayerOnAirJumpAfterEventSignal;
    readonly playerOnLand: PlayerOnLandAfterEventSignal;
    readonly playerOnEquip: PlayerOnEquipAfterEventSignal;
    readonly playerOnUnequip: PlayerOnUnequipAfterEventSignal;
  }
  interface Player {
    readonly isMortal: boolean;
    clearItem(typeId: string, maxCount?: string, data?: number): void;
    readonly isUsingItem: boolean;
    getItems(typeId?: string): { equipments: Map<string, ItemStack>; inventory: Map<number, ItemStack> };
    damageItem(slot: EquipmentSlot, damage?: number): ItemStack | undefined;
    stopSound(id: string): void;
    gamemode: GameMode;
    inventory: Container;
    setActionBar(rawMessage: string | RawMessage): void;
    setTitle(rawMessage: string, option?: any): void;
    ipMovement: boolean;
    ipCamera: boolean;
  }
  interface Entity {
    commandRun(...commands: (string | string[])[]): CommandResult;
    readonly chunk: Vector3;
    effectAdd(effectName: string, durationInSeconds?: number, amplifier?: number, hideParticles?: boolean): void;
    effectClear(effectType?: string | null): void;
    sendMolang(molang: string): void;
    toItemStack(): ItemStack | undefined;
    readonly projectileComponent: EntityProjectileComponent | undefined;
    readonly itemComponent: EntityItemComponent | undefined;
    readonly ridingComponent: EntityRidingComponent | undefined;
    readonly movementComponent: EntityMovementComponent | undefined;
    readonly healthComponent: EntityHealthComponent | undefined;
    readonly equippableComponent: EntityEquippableComponent | undefined;
    readonly inventoryComponent: EntityInventoryComponent | undefined;
    readonly typeFamilyComponent: EntityTypeFamilyComponent | undefined;
    readonly tameableComponent: EntityTameableComponent;

    readonly typeFamilies: string[];
    readonly headLocation: Vector3;
    readonly viewDirection: Vector3;
    readonly isPlayer: boolean;
    readonly ride: Entity | undefined;
    readonly isRiding: boolean;
    projectileOwner: Entity | undefined;
    speed: number;
    getFacingOffset(distance: number, offset?: Vector3): Vector3;
    health: number;
    readonly maxHealth: number;
    readonly missingHealth: number;
    dispose(): void;
    getEquipment(slot: EquipmentSlot): ItemStack | undefined;
    setEquipment(slot: EquipmentSlot, item: ItemStack): boolean | undefined;
    setMainhand(item: ItemStack | undefined): void;
    setOffhand(item: ItemStack | undefined): void;
    setHead(item: ItemStack | undefined): void;
    setChest(item: ItemStack | undefined): void;
    setLegs(item: ItemStack | undefined): void;
    setFeet(item: ItemStack | undefined): void;
    readonly inventory: Container | undefined;
    addItem(itemStack: ItemStack): void;
    tameOwner: Entity | undefined;
    rotation: Vector2;
    readonly velocity: Vector3;
    readonly coordinates: Vector3;
    readonly cx: number;
    readonly cy: number;
    readonly cz: number;
    x: number;
    y: number;
    z: number;
    rx: number;
    ry: number;
    readonly hx: number;
    readonly hy: number;
    readonly hz: number;
    readonly vx: number;
    readonly vy: number;
    readonly vz: number;
    readonly vdx: number;
    readonly vdy: number;
    readonly vdz: number;
  }
  interface ItemStack {
    readonly isVanillaBlock: boolean;
    compare(itemStack: ItemStack | null | undefined): boolean;
    readonly enchantableComponent: ItemEnchantableComponent;
    readonly enchantmentSlots: EnchantmentSlot[] | undefined;
    addEnchantment(...enchantments: Enchantment[]): void;
    getEnchantment(enchantmentType: EnchantmentType): Enchantment | undefined;
    hasEnchantment(enchantmentType: EnchantmentType): boolean;
    removeEnchantment(enchantmentType: EnchantmentType): void;
    removeAllEnchantments(): void;
    readonly durabilityComponent: ItemDurabilityComponent;
    durability: number;
  }
  interface Container {
    forEachSlot(cb: (slotObj: ContainerSlot, slotId: number) => void): void;
    getItems(): Map<number, ItemStack>;
    sort(cb: (a: ItemStack, b: ItemStack) => number): void;
  }
  interface Block {
    getAdjacentBlocks(): Block[];
    getState(state: string): any;
    setState(state: string, value: any): void;
    readonly inventoryComponent: any;
    readonly inventory: Container | undefined;
    getItems(typeId?: string): Map<number, ItemStack>;
  }
  interface BlockPermutation {
    setState(state: string, value: any): BlockPermutation;
    getState(state: string): any;
  }
  interface Dimension {
    weather: WeatherType | { type: WeatherType; duration: number } | undefined;
    commandRun(...commands: (string | string[])[]): CommandResult;
  }

  interface ScriptEventCommandMessageAfterEvent {
    readonly source: Block | Entity | undefined;
  }
}
